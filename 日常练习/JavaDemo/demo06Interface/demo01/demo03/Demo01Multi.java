package Demo.demo06Interface.demo01.demo03;
/*
代码当中体现多态性,其实就一句话,父类引用指向子类对象
格式
父类名称 对象名 = new 子类名称();
或者:
接口名称 对象名 = new 子类名称();

访问成员变量的两种方式:
1.直接通过对象名称访问成员变量,看等号左边是谁,优先用谁,没有则向上找
2.间接通过成员方法访问成员变量,看该方法属于谁,优先有谁,没有则向上找

口诀:编译看左边,运行看右边
成员变量: 编译看左边,运行还看左边
成员方法: 编译看左边,运行看右边

多态的好处:
无论右边new的时候换成那个子类对象,等号左边调用方法都不会变化


对象的向上转型,其实就是多态写法
格式: 父类名称 对象名 = new 子类名称();    Animal animal = new Cat();
含义:右侧创建一个子类对象,把他当做父类看待    创建了一只猫,当动物看没问题
注意:向上转型一定是安全的,从小范围转成了大范围,但是有一个弊端:
对象一旦向上转型为父类,那么就无法调用子类原本特有方法
比如 猫类转型为动物类,可以有 吃 方法,但不能执行 猫抓老鼠 猫特有的子类方法

解决方法:向下转型
对象的向下转型,其实是一个(还原)的动作
格式: 子类名称 对象名 = (子类名称)父类对象名    Cat cat = (Cat)animal;
含义:将父类对象,[还原]成为本来的子类对象
猫转成动物,只能还原成猫,不能还原成狗,强行向下错误转型会出错,编译不会报错,运行会出错

 */
public class Demo01Multi
{
    public static void main(String[] args)
    {
        Fu one = new Zi();
       one.method();//方法同名时,右边new的是谁用谁的,没有则向上找
        //子类没有覆盖重写,就是用父类的方法
        //子类如果覆盖重写,就是用子类的方法

         //one.methodZi(); 错误写法

    }
}
